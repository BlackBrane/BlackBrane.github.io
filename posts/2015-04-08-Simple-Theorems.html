<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <link rel="icon" type="image/x-icon" href="../images/favicon.ico" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>BlackBrane - Spinors and Simple Theorems in Idris</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <!--<script src="https://apis.google.com/js/platform.js" async defer></script>-->
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">BlackBrane</a>
            </div>
            <div id="navigation">
                <a href="https://github.com/BlackBrane"><!--<img src="/images/gh.svg" width="16" />-->Code</a>
                <a href="../archive.html">Posts</a>
                <a href="../phys-math-resources">Physics Resources</a>
                <a href="../cs-resources">CS Resources</a>
                <a href="../contact.html">Contact</a>
            </div>
        </div>

        <div id="content">
            <h1>Spinors and Simple Theorems in Idris</h1>

            <div class="info">
    Posted on April  8, 2015
    
        by Cliff
    
</div>

<p>This is a maiden post for my <a href="http://jaspervdj.be/hakyll">hakyll</a>-based blog. I don’t claim the content to be particularly remarkable or original, it’s just a relatively simple exercise dependently-typed programming applied to an interesting structure in theoretical physics. It also provides a good test of both syntax-highlighting and math-rendering facilities. The code shown here can be found <a href="https://github.com/BlackBrane/quantum/blob/master/Spinor.idr">on github</a>.</p>
<p>I won’t discuss the physics involved in any detail, but this problem is about describing fermions – i.e. matter particles like electrons – in arbitrary numbers of spacetime dimensions. What we need to do is find sets of matrices <span class="math">\(\Gamma^\mu\)</span> that satisfy an anticommutation called the gamma matrix algebra:</p>
<p><span class="math">\[ \{\Gamma^\mu,\Gamma^\nu\} = 2\eta^{\mu\nu} \]</span></p>
<p>Or, unpacking the notation a bit:</p>
<p><span class="math">\[ \Gamma^\mu\Gamma^\nu + \Gamma^\nu\Gamma^\mu = 2 \ {\rm diag} (-1,1,1, ... 1) \]</span></p>
<p>The greek indices <span class="math">\(\mu,\nu\)</span> are spacetime indices so we need a set of D matrices satisfying this relation to describe physics in D dimensions. The equation itself can be thought of as a matrix in the spacetime indices, while it’s entries are matrices in the same space as the gamma matrices (<em>not</em> in spacetime indices). So, in words, this equation says that the anticommutator of any two gamma matrices (the sum of both ways to multiply them) is nonzero only when the two are the same, and then the result is proportional to the identity matrix, with a factor of <span class="math">\(-1\)</span> only for <span class="math">\(\mu=\nu=0\)</span>.</p>
<p>It turns out we can recursively solve the anticommutation relation, obtaining gamma matrices for all spacetime dimensions <span class="math">\(D \geq 2\)</span>, starting with the base case of <span class="math">\(D=2\)</span>. So we begin with the following pair.</p>
<p><span class="math">\[
\Gamma^0 = \left[ \begin{array}{cc} 0 &amp; 1 \\ -1 &amp; 0 \end{array} \right] \ \ , \ \
\Gamma^1 = \left[ \begin{array}{cc} 0 &amp; 1 \\  1 &amp; 0 \end{array} \right]
\]</span></p>
<p>We can describe these in Idris as follows.</p>
<pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">g0</span> <span class="ot">:</span> <span class="dt">Matrix</span> <span class="dv">2</span> <span class="dv">2</span> (<span class="dt">Complex</span> <span class="dt">ZZ</span>)
g0 <span class="fu">=</span> [[c0, c1], [cm1, c0]]

<span class="fu">g1</span> <span class="ot">:</span> <span class="dt">Matrix</span> <span class="dv">2</span> <span class="dv">2</span> (<span class="dt">Complex</span> <span class="dt">ZZ</span>)
g1 <span class="fu">=</span> [[c0, c1], [c1, c0]]</code></pre>
<p>Now we can tackle the general case, beginning first with <strong>even dimensions</strong> <span class="math">\(D=2k+2\)</span>. If we call the gammas from the previous even number of dimensions <span class="math">\(\gamma^\mu\)</span>, with the index ranging from <span class="math">\(0 ... 2k-1\)</span>, then we can form the gamma matrices for the next even number of dimensions by tensor-multiplying all the <span class="math">\(\gamma^\mu\)</span> by a certain 2-by-2 matrix, and then adding two more matrices of a particular constant form.</p>
<p><span class="math">\[\Gamma^\mu = \gamma^\mu \otimes \left[ \begin{array}{cc} -1 &amp; 0 \\ 0 &amp; 1 \end{array} \right]\]</span></p>
<p><span class="math">\[\Gamma^{D-2} = I \otimes \left[ \begin{array}{cc} 0 &amp; 1 \\ 1 &amp; 0 \end{array} \right]\]</span></p>
<p><span class="math">\[
\Gamma^{D-1} = I \otimes \left[ \begin{array}{cc} 0 &amp; -i \\ i &amp; 0 \end{array} \right]
\]</span></p>
<p>It’s pretty easy to check that the gammas generated in this way do in fact satisfy the anticommutation relation, by the general properties of the tensor product. So we’ve furnished representations for <span class="math">\(D=2k+2\)</span> dimensional spacetimes consisting of D matrices of size <span class="math">\(2^{k+1}\)</span>.</p>
<p>To get a representation for an <strong>odd</strong> number of dimensions we take the set of gammas from the previous even dimension, and add to it their product multiplied <span class="math">\(i^{-k}\)</span>. This last matrix is conventionally called simply <span class="math">\(\Gamma\)</span>, or “the fifth gamma matrx” since it also frequently appears in formulae for the usual 4 spacetime dimensions.</p>
<p><span class="math">\[\Gamma = \frac{1}{i^k} (Γ^0 ... Γ^{D-1})\]</span></p>
<p>Now I want to implement this recursive definition in Idris, and in particular I want to do it while enforcing these general numerical properties with the type system. Here’s one way to write the function to produce the even-dimension gammas.</p>
<pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">gammaEven</span> <span class="ot">:</span> (k <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">Vect</span> (k<span class="fu">*</span><span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">$</span> <span class="dt">Matrix</span> (power <span class="dv">2</span> (<span class="dt">S</span> k)) (power <span class="dv">2</span> (<span class="dt">S</span> k)) (<span class="dt">Complex</span> <span class="dt">ZZ</span>)
gammaEven <span class="dt">Z</span>      <span class="fu">=</span> [g0, g1]
gammaEven (<span class="dt">S</span> k) <span class="fu">?=</span> {<span class="dt">Lemma_1</span>} map (<span class="fu">\</span>g <span class="ot">=&gt;</span> g <span class="fu">&lt;&amp;&gt;</span> (g1 <span class="fu">&lt;&gt;</span> g0)) (gammaEven k) <span class="fu">++</span> 
  [<span class="dt">Id</span> <span class="fu">&lt;&amp;&gt;</span> g1, <span class="dt">Cmi</span> <span class="fu">&lt;#&gt;</span> <span class="dt">Id</span> <span class="fu">&lt;&amp;&gt;</span> g0]</code></pre>
<p>There are a few things to take note of here. First I should point out the various operators that are implementing the necessary operations on matrices: <code>&lt;&gt;</code> is matrix multiplication, while <code>&lt;&amp;&gt;</code> is tensor mutiplication. These are defined in a simple <a href="https://github.com/idris-lang/Idris-dev/blob/master/libs%2Fcontrib%2FData%2FMatrix.idr">Matrix</a> library I wrote. Also the <strong><code>&lt;#&gt;</code></strong> operator signifies rescaling a matrix by a scalar factor, and more generally rescales any Module over a Ring, so this resides in <a href="https://github.com/idris-lang/Idris-dev/blob/master/libs%2Fcontrib%2FData%2FMatrix.idr">Algebra.idr</a> with related classes.</p>
<p>Another interesting characteristic of dependently typed programming we see here is the ability for some important-but-tedious details to be inferred, during the process called <em>elaboration</em>. Namely this <code>Id</code> function produces an identity matrix, but both the size and the entry-type of this matrix are implicit parameters. We don’t need to supply any of them here, since all are clear from the context. This is exactly the same thing we expected a human reader to understand when we wrote down this definition in the mathematical form above. This is a remarkable inversion of the more common outlook in programming to want to have <em>types</em> be inferred. Our early experiences with dependently typed programming indicates that a much more powerful approach is to infer <em>code</em> based on our <em>types.</em> This is particularly true in the context of the facilities for text editors that work with the compiler, like the Idris-editing modes for emacs and vim.</p>
<p>Finally it’s important to note that the second line of this definition uses the token <code>?=</code> instead of the standard equals sign <code>=</code> indicating that, though this function really is type-correct, the type-correctness is not obvious, so we need to demonstrate it to the type checker. The <code>{Lemma_1}</code> is the optional name given to the <em>metavariable</em> that stands in for the proof that we will supply. Let’s first look at the detailed complaint that Idris will give us if we tried to straightforwardly define this part of our function without <code>?=</code>.</p>
<pre><code>Type checking ./Spinor.idr
Spinor.idr:37:99:When elaborating right hand side of gammaEven:
When elaborating an application of function Control.Algebra.VectorSpace.&lt;#&gt;:
        Can't unify
                Matrix (h1 * 2) (h1 * 2) (Complex ZZ) (Type of Id &lt;&amp;&gt; g0)
        with
                Vect (plus (plus (power 2 k) (plus (power 2 k) 0))
                           (plus (plus (power 2 k) (plus (power 2 k) 0)) 0))
                     (Vect (plus (plus (power 2 k) (plus (power 2 k) 0))
                                 (plus (plus (power 2 k) (plus (power 2 k) 0))
                                       0))
                           (Complex ZZ)) (Expected type)
        
        Specifically:
                Can't unify
                        mult h1 2
                with
                        plus (plus (power 2 k) (plus (power 2 k) 0))
                             (plus (plus (power 2 k) (plus (power 2 k) 0)) 0)
Metavariables: Spinor.gammaEven</code></pre>
<p>The Idris type checker is saying: Okay, clearly <code>Id &lt;&amp;&gt; g0</code> is a square matrix of even size, but what I need in that position is a square matrix of size <span class="math">\((2^k + (2^k + 0)) + ((2^k + (2^k + 0)) + 0)\)</span>. To a human it’s obvious that this expression could only represent an even number, but this relies on a certain understanding of arithmetic. While any computer system could be taught to reason about such things easily enough, in a dependently typed system we want to be systematic about this: We have the power to produce checkable proofs that such manipulations are in fact valid, and it is largely the purpose of such a type system to provide these assurances to us. While it’s possible to subvert the type checker when necessary, if any proof obligations are becomming too burdensome it’s probably a sign that you should be using less-stringent types. For example we could have sidestepped this exercise entirely if we had used simple lists instead of vectors with length information in the type.</p>
<p>This sort of unification error (or more accurately, <em>obligation</em>) is a kind that seems to make for good practice. There is nothing at all conceptually challenging about it, though it does allow for the character-building experience of sorting through something a bit more hairy than the usual simple examples. The proof that I ended up with is shown below. I had to introduce three sub-lemmas to get the main result. It’s not necessarily pretty but it got the job done. One particular way this might be refined now is with Idris’s new <strong>claim</strong> tactic which would make it easier to introduce the sub-goals into the main proof.</p>
<pre class="sourceCode idris"><code class="sourceCode idris"><span class="co">---------- Proofs ----------</span>

<span class="fu">multTwoRightPlusTimesOne</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> mult n <span class="dv">2</span> <span class="fu">=</span> n <span class="fu">+</span> (mult n <span class="dv">1</span>)
multTwoRightPlusTimesOne <span class="fu">=</span> <span class="kw">proof</span>
  <span class="kw">intros</span>
  <span class="kw">rewrite</span> (multRightSuccPlus n (<span class="dt">S</span> <span class="dt">Z</span>))
  <span class="kw">trivial</span>

<span class="fu">multTwoRightPlus</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> n <span class="fu">*</span> <span class="dv">2</span> <span class="fu">=</span> plus n n
multTwoRightPlus <span class="fu">=</span> <span class="kw">proof</span>
  <span class="kw">intros</span>
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> multTwoRightPlusTimesOne n)
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> multOneRightNeutral n)
  <span class="kw">trivial</span>

<span class="fu">plusPlusZero</span> <span class="ot">:</span> (x,y <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> x <span class="fu">+</span> y <span class="fu">=</span> x <span class="fu">+</span> (y <span class="fu">+</span> <span class="dv">0</span>)
plusPlusZero <span class="fu">=</span> <span class="kw">proof</span>
  <span class="kw">intros</span>
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> plusZeroRightNeutral y)
  <span class="kw">trivial</span>

<span class="dt">Lemma_1</span> <span class="fu">=</span> <span class="kw">proof</span>
  <span class="kw">intros</span>
  <span class="kw">rewrite</span> (plusZeroRightNeutral (plus (mult k <span class="dv">2</span>) <span class="dv">2</span>))
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> plusSuccRightSucc (plus (mult k <span class="dv">2</span>) <span class="dv">2</span>) <span class="dv">0</span>)
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> plusSuccRightSucc (plus (mult k <span class="dv">2</span>) <span class="dv">2</span>) <span class="dv">1</span>)
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> plusZeroRightNeutral (power <span class="dv">2</span> k))
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> plusZeroRightNeutral (power <span class="dv">2</span> k <span class="fu">+</span> (power <span class="dv">2</span> k)))
  <span class="kw">rewrite</span> (multTwoRightPlus (plus (power <span class="dv">2</span> k) (power <span class="dv">2</span> k)))
  <span class="kw">rewrite</span> (sym <span class="fu">$</span> plusPlusZero (power <span class="dv">2</span> k) (power <span class="dv">2</span> k))
  <span class="kw">trivial</span></code></pre>
<p>So just briefly, these <code>rewrite</code> statements take a mathematical rule in the form of an equation, and replaces instances of the right side in the current term with the left-hand side. This is often used with <code>sym</code> which reflects the equation. Most of the names I invoke, like <code>plusZeroRightNeutral</code> for example, are theorems from the standard library. Their types can be looked up at the REPL with the <code>:doc</code> command. And if you need to find a particular theorem to prove your result, you can use Idris’s wonderful type-directed search feature to figure out if it already exists. For example <code>:search plus n 0 = n</code> turns up the corresponding theorem <code>plusZeroRightNeutral</code>. If you’d like to learn about proving in Idris properly, consult the relevant <a href="http://docs.idris-lang.org/en/latest/tutorial/theorems.html">section of the docs</a>, since I’m only attempting to give a general flavor.</p>
<p>Finally, here is the simple function that implements the extra gamma appearing in odd-spacetime-dimensional representations of the anticommutation relation.</p>
<pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">gamma</span> <span class="ot">:</span> <span class="dt">Vect</span> (k<span class="fu">*</span><span class="dv">2+2</span>) <span class="fu">$</span> <span class="dt">Matrix</span> (power <span class="dv">2</span> <span class="fu">$</span> <span class="dt">S</span> k) (power <span class="dv">2</span> <span class="fu">$</span> <span class="dt">S</span> k) (<span class="dt">Complex</span> <span class="dt">ZZ</span>) <span class="ot">-&gt;</span>
        <span class="dt">Matrix</span> (power <span class="dv">2</span> <span class="fu">$</span> <span class="dt">S</span> k) (power <span class="dv">2</span> <span class="fu">$</span> <span class="dt">S</span> k) (<span class="dt">Complex</span> <span class="dt">ZZ</span>)
gamma {k} gs <span class="fu">=</span> (power' <span class="dt">Cmi</span> k) <span class="fu">&lt;#&gt;</span> (product' gs)</code></pre>
<p>The type of this function is more detailed than it needs to be: it would work exactly the same if I made the size of the matrix an arbitrary free variable, but I opted to keep the detailed type for conceptual reasons (usually we write functions in as general a form as possible, but here I’m restricting to the form valid for the problem). In addition, writing the size of the vector of matrices as <span class="math">\(2k+1\)</span> has the convenient result that we can simply pass the implicit parameter <code>{k}</code> to the function body and then express the factor <span class="math">\(i^{-k}\)</span> in a simple form.</p>
<p>In summary, the point here is not that dependent types are ushering in a revolution in the approach to mathematical fields like physics – <em>yet.</em> But it does give us a fantastic system that allows for a wide spectrum of programming styles; where the familiar Haskell-like approach to functional programming is possible, but in which we also have the chance to formalize and prove the properties of our programs that really matter. In the words of <a href="http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf">Conor McBride et al</a>, <em>“While the price for formally certified software may be high, it is good to know that we can pay it in installments and that we are free to decide how far we want to go. Dependent types reduce certification to type checking, hence they provide a means to convince others that the assertions we make about our programs are correct. Dependently typed programs are, by their nature, proof carrying code.”</em></p>

        </div>
        <div id="footer">
            <div id="footerleft">
                <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" border="0">
                <img alt="Creative Commons License" src="../images/CC-BY-NC.png" /></a>
            </div>
            <div id="footerright">
                Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            </div>
        </div>
    </body>
</html>
